const process   = require('process')
const fs        = require('fs-extra')

const rollup    = require('rollup')
const path      = require('path')
const vue       = require('rollup-plugin-vue2')
const css       = require('rollup-plugin-css-only')
const buble     = require('@rollup/plugin-buble')
const commonjs  = require('@rollup/plugin-commonjs')
const json      = require('@rollup/plugin-json')
const { nodeResolve } = require('@rollup/plugin-node-resolve')
const { babel } = require('@rollup/plugin-babel')
const nodePolyfills = require('rollup-plugin-polyfill-node')
const camelcase = require('camelcase')

console.log('========== building vue files ==========')

var felibName = ''
if(process.argv.length >= 3) {
    felibName = process.argv[2]
} else {
    console.log('please provide a name for the felib to use')
    process.exit(-1)
}

console.log('building felib', felibName)

var basePath = 'src/main/content/jcr_root/apps'
var distBasePath = 'target/classes/etc/felibs/'+felibName

const timestampTokenFile = path.resolve(distBasePath, '../../../../', '.timestamp.buildvue.token')

/** creatte the target directories
 *
 */
fs.mkdirsSync(distBasePath)
fs.mkdirsSync(distBasePath+'/css')
fs.mkdirsSync(distBasePath+'/js')

let timestamp

try {
    timestamp = parseInt(fs.readFileSync(timestampTokenFile, 'utf-8'))
} catch (e) {
    timestamp = 0;
}

// list can be regenerated by
// $ cat *js | egrep "': require\(" | sed -r "s/ *//" | sed -r "s/:.*/,/" | sort | fmt -w 120
// in lodash directory in node_modules
var lodashExported = ['add', 'after', 'ary', 'assign', 'assignIn', 'assignInWith', 'assignWith', 'at', 'at', 'attempt', 'before', 'bind',
    'bindAll', 'bindKey', 'camelCase', 'capitalize', 'castArray', 'ceil', 'chain', 'chunk', 'clamp', 'clone', 'cloneDeep',
    'cloneDeepWith', 'cloneWith', 'commit', 'compact', 'concat', 'cond', 'conforms', 'conformsTo', 'constant', 'countBy',
    'create', 'curry', 'curryRight', 'debounce', 'deburr', 'defaults', 'defaultsDeep', 'defaultTo', 'defer', 'delay',
    'difference', 'differenceBy', 'differenceWith', 'divide', 'drop', 'dropRight', 'dropRightWhile', 'dropWhile', 'each',
    'eachRight', 'endsWith', 'entries', 'entriesIn', 'eq', 'escape', 'escapeRegExp', 'every', 'extend', 'extendWith',
    'fill', 'filter', 'find', 'findIndex', 'findKey', 'findLast', 'findLastIndex', 'findLastKey', 'first', 'flatMap',
    'flatMapDeep', 'flatMapDepth', 'flatten', 'flattenDeep', 'flattenDepth', 'flip', 'floor', 'flow', 'flowRight',
    'forEach', 'forEachRight', 'forIn', 'forInRight', 'forOwn', 'forOwnRight', 'fromPairs', 'functions', 'functionsIn',
    'get', 'groupBy', 'gt', 'gte', 'has', 'hasIn', 'head', 'identity', 'includes', 'indexOf', 'initial', 'inRange',
    'intersection', 'intersectionBy', 'intersectionWith', 'invert', 'invertBy', 'invoke', 'invokeMap', 'isArguments',
    'isArray', 'isArrayBuffer', 'isArrayLike', 'isArrayLikeObject', 'isBoolean', 'isBuffer', 'isDate', 'isElement',
    'isEmpty', 'isEqual', 'isEqualWith', 'isError', 'isFinite', 'isFunction', 'isInteger', 'isLength', 'isMap',
    'isMatch', 'isMatchWith', 'isNaN', 'isNative', 'isNil', 'isNull', 'isNumber', 'isObject', 'isObjectLike',
    'isPlainObject', 'isRegExp', 'isSafeInteger', 'isSet', 'isString', 'isSymbol', 'isTypedArray', 'isUndefined',
    'isWeakMap', 'isWeakSet', 'iteratee', 'join', 'kebabCase', 'keyBy', 'keys', 'keysIn', 'last', 'lastIndexOf',
    'lodash', 'lowerCase', 'lowerFirst', 'lt', 'lte', 'map', 'mapKeys', 'mapValues', 'matches', 'matchesProperty',
    'max', 'maxBy', 'mean', 'meanBy', 'memoize', 'merge', 'mergeWith', 'method', 'methodOf', 'min', 'minBy', 'mixin',
    'multiply', 'negate', 'next', 'noop', 'now', 'nth', 'nthArg', 'omit', 'omitBy', 'once', 'orderBy', 'over', 'overArgs',
    'overEvery', 'overSome', 'pad', 'padEnd', 'padStart', 'parseInt', 'partial', 'partialRight', 'partition', 'pick',
    'pickBy', 'plant', 'property', 'propertyOf', 'pull', 'pullAll', 'pullAllBy', 'pullAllWith', 'pullAt', 'random',
    'range', 'rangeRight', 'rearg', 'reduce', 'reduceRight', 'reject', 'remove', 'repeat', 'replace', 'rest', 'result',
    'reverse', 'reverse', 'round', 'sample', 'sampleSize', 'set', 'setWith', 'shuffle', 'size', 'slice', 'snakeCase',
    'some', 'sortBy', 'sortedIndex', 'sortedIndexBy', 'sortedIndexOf', 'sortedLastIndex', 'sortedLastIndexBy',
    'sortedLastIndexOf', 'sortedUniq', 'sortedUniqBy', 'split', 'spread', 'startCase', 'startsWith', 'stubArray',
    'stubFalse', 'stubObject', 'stubString', 'stubTrue', 'subtract', 'sum', 'sumBy', 'tail', 'take', 'takeRight',
    'takeRightWhile', 'takeWhile', 'tap', 'template', 'templateSettings', 'throttle', 'thru', 'times', 'toArray',
    'toFinite', 'toInteger', 'toIterator', 'toJSON', 'toLength', 'toLower', 'toNumber', 'toPairs', 'toPairsIn', 'toPath',
    'toPlainObject', 'toSafeInteger', 'toString', 'toUpper', 'transform', 'trim', 'trimEnd', 'trimStart', 'truncate',
    'unary', 'unescape', 'union', 'unionBy', 'unionWith', 'uniq', 'uniqBy', 'uniqueId', 'uniqWith', 'unset', 'unzip',
    'unzipWith', 'update', 'updateWith', 'upperCase', 'upperFirst', 'value', 'valueOf', 'values', 'valuesIn', 'without',
    'words', 'wrap', 'wrapperChain', 'xor', 'xorBy', 'xorWith', 'zip', 'zipObject', 'zipObjectDeep', 'zipWith',
]

/**
 * compile a single file
 *
 * @param file
 * @returns {{name: string, nameCamelCase: *, nameCapitalCamelCase: string}}
 */
async function compileComponent(file){

    compiling.push(file)

    console.log("compiling vue file: .%s", file)
    // get component name from file name (file: a.vue, name: a)
    var name = file.substring(1, file.lastIndexOf('/')).toLowerCase().split('/').join('-')
    var nameCamelCase = camelcase(name)
    var nameCapitalCamelCase = nameCamelCase.charAt(0).toUpperCase() + nameCamelCase.slice(1)

    // each component needs a unique module name
    var moduleName = 'cmp'+nameCapitalCamelCase

    // compile the Vue component and give us a .js and .css
    await rollup.rollup({
        input: `${basePath}${file}`,
        plugins: [
            commonjs(),
            nodePolyfills(),
            nodeResolve(),
            json(),
            vue({
                compiler: () => {},
                compileTemplate: true,
                css: false
            }),
            css({output:`${distBasePath}/css/${nameCamelCase}.css`}),
            babel({ babelHelpers: 'bundled' }),
        ],
        // will treat all imports like "import add from 'lodash/add'" as external
        external: ['vue', 'lodash'].concat(lodashExported.map(fName => `lodash/${fName}`))
    }).then( async function(bundle) {

        await bundle.write({
            format: 'iife',
            name: moduleName,
            file:`${distBasePath}/js/${nameCamelCase}.js`,
            // will treat all imports like "import add from 'lodash/add'" as external
            // and they will simply resolve to _.add
            globals: {...{
                tools: 'tools',
                log: 'log',
                'vue': 'Vue',
                'lodash': '_',
            }, ...Object.fromEntries(lodashExported.map(fName => [`lodash/${fName}`, `_.${fName}`]))}

        }).then( function() {
            const index = compiling.indexOf(file)
            if(index >= 0) {
                compiling.splice(index, 1)
            }
            updateIndexFiles()
        }).catch( (error) => {
            console.log(error)}
        )
    }).catch( (error) => {
        console.log(`Error compiling ${file}:\n`, error)
        const index = compiling.indexOf(file)
        if(index >= 0) {
            compiling.splice(index, 1)
        }
    })
    return { name: name, nameCamelCase: nameCamelCase, nameCapitalCamelCase: nameCapitalCamelCase}
}

/**
 * rewrites the js.txt and css.txt file used to combine the css and js file in the frontend
 *
 */
function updateIndexFiles() {
    var jsFiles = readDirs(distBasePath+'/', distBasePath + '/js', '.js')
    jsFiles.unshift('<!-- auto generated by build -->')
    fs.writeFileSync(distBasePath+'/js.txt', jsFiles.join('\n'))

    var cssFiles = readDirs(distBasePath+'/', distBasePath + '/css', '.css')
    cssFiles.unshift('<!-- auto generated by build -->')
    fs.writeFileSync(distBasePath+'/css.txt', cssFiles.join('\n'))


    if(compiling.length === 0) {
        console.log('done compiling')

        if(process.argv[3] === 'upload') {
            console.log('upload')
            const slang = require('./slang.js')
            slang.setOptions({
                port: 8080,
                host: 'localhost'
            })


            const appName = felibName
            console.log('felib name is', appName)

            process.chdir('target/classes')
            slang.up('etc/felibs/' + appName + '/js.txt').then(function (status) {
//                console.log('success', status)
            }).catch(function (status, err) {
                console.error('error', status, err)
            });
            slang.up('etc/felibs/' + appName + '/css.txt').then(function (status) {
//                console.log('success', status)
            }).catch(function (status, err) {
                console.error('error', status, err)
            });

            jsFiles.slice(1).forEach( function(file) {
                slang.up('etc/felibs/' + appName + '/'+file).then(function (status) {
//                    console.log('success', status)
                }).catch(function (status, err) {
                    console.error('error', status, err)
                });
            })
            cssFiles.slice(1).forEach( function(file) {
                slang.up('etc/felibs/' + appName + '/'+file).then(function (status) {
//                    console.log('success', status)
                }).catch(function (status, err) {
                    console.error('error', status, err)
                });
            })
            //     slang.up('etc/felibs/'+appName+'/js/'+appName+'Components'+componentName.charAt(0).toUpperCase()+componentName.substring(1)+'.js').then(function(status) {
            //         console.log('success',status)
            //     }).catch(function(status, err) {
            //         console.error('error', status, err)
            //     });
            // }
        }
    }
}

/**
 *
 * read a directory and its children and return all the files with the given extension
 *
 * @param basePath
 * @param path
 * @param extFilter
 * @returns {Array}
 */
function readDirs(basePath, path, extFilter, mTimeMin = 0) {
    var ret = new Array()
    var files = fs.readdirSync(path)
    files.forEach( function(file) {
        var filePath = path + '/' + file;
        if(filePath.endsWith(extFilter)) {
            const fileStats = fs.statSync(filePath)
            if (fileStats.mtime.getTime() > mTimeMin) {
                ret.push(filePath.slice(basePath.length))
            }
        }
        var stats = fs.statSync(filePath)
        if(stats.isDirectory()) {
            ret = ret.concat(readDirs(basePath, filePath, extFilter, mTimeMin))
        }
    })
    return ret;
}

// find all the vue files in this project
var vueFiles = readDirs(basePath, basePath, '.vue', timestamp)
//var allFiles = readDirs(basePath, basePath, '.vue')
var compiling = []
// for each of the files compile it
for(let i = 0; i < vueFiles.length; i++) {
    compileComponent(vueFiles[i])
}

fs.writeFileSync(timestampTokenFile, `${Date.now()}`, 'utf-8');


